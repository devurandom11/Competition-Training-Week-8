<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Network Workshop with Router, DMZ, and Servers</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
        }
        h1 {
            font-size: 2em;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        h2 {
            font-size: 1.5em;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }
        h3 {
            font-size: 1.25em;
        }
        ul, ol {
            padding-left: 2em;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        code {
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 85%;
        }
        pre {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 16px;
            overflow: auto;
            margin-bottom: 16px;
            font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre code {
            background: none;
            padding: 0;
        }
        blockquote {
            border-left: 4px solid #dfe2e5;
            margin-left: 0;
            padding-left: 16px;
            color: #6a737d;
        }
        hr {
            height: 1px;
            background-color: #e1e4e8;
            border: none;
            margin: 24px 0;
        }
        table {
            border-collapse: collapse;
            margin: 20px 0;
            width: 100%;
        }
        table th, table td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        table th {
            background-color: #f6f8fa;
            font-weight: 600;
        }
        img {
            max-width: 100%;
            height: auto;
        }
        .alert {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        .alert-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        .alert-info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .highlight {
            background-color: #fffbdd;
            padding: 2px;
        }
        /* Syntax highlighting */
        .hljs-keyword, .bash .hljs-built_in {
            color: #d73a49;
        }
        .hljs-string {
            color: #032f62;
        }
        .hljs-number {
            color: #005cc5;
        }
        .hljs-comment {
            color: #6a737d;
        }
        .hljs-variable {
            color: #e36209;
        }
    </style>
</head>
<body>
    <h1>Deploying a Virtual Network with Router, DMZ, and Servers – Step-by-Step Workshop</h1>

    <h2>Overview and Objectives</h2>
    <p>In this workshop, we will build a virtual network environment with four Linux VMs acting in different roles on separate subnets (LAN and DMZ) behind a router/firewall. We'll configure networking and services step-by-step, including firewall rules and security hardening. By the end, you will have:</p>
    <ul>
        <li>Alpine Linux as a router (firewall) providing WAN internet access to two internal networks (LAN and DMZ) via NAT.</li>
        <li>CentOS as a web server in the DMZ running a LAMP stack (Linux, Apache, MariaDB, PHP) with Nginx as a reverse proxy in front of Apache, and SELinux in enforcing mode to illustrate policy enforcement.</li>
        <li>Arch Linux as a file server in the LAN running vsftpd (FTP server) and Samba (SMB file sharing), accessible only from the LAN.</li>
        <li>Ubuntu Desktop as a jump-box in the LAN, which will be used to access the other servers (e.g. SSH into them, browse the web service, test FTP/SMB, etc.). This simulates an admin workstation that has access to both networks.</li>
    </ul>

    <div class="alert alert-info">
        <strong>*** The credentials for the VMs are:</strong>
        <ul>
            <li>Alpine: <code>administrator/Coastline!</code></li>
            <li>CentOS: <code>administrator/Coastline!</code></li>
            <li>Arch: <code>administrator/Coastline!</code></li>
            <li>Ubuntu: <code>administrator/Coastline!</code></li>
        </ul>
    </div>

    <h3>Network segments</h3>
    <p>The Alpine router will separate three networks (one WAN, plus two internal networks). The LAN subnet will be <code>192.168.10.0/24</code> (trusted internal network) and the DMZ subnet will be <code>10.10.10.0/24</code> (perimeter network for public-facing server). The router's firewall will be configured so that external (WAN) traffic can reach the DMZ web server (on specific ports) but not the LAN, and the LAN can reach the DMZ (for example, the jump-box can reach the web server), while the DMZ cannot initiate connections into the LAN. The Arch file server will be restricted to only communicate within the LAN and not with the DMZ, whereas the Ubuntu jump-box will be allowed to access the DMZ. All internet-bound traffic from LAN/DMZ will go through the Alpine router (which performs NAT).</p>

    <h2>Network Topology</h2>
    <ul>
        <li><strong>Alpine Linux Router</strong> – three network interfaces:
            <ul>
                <li><code>eth0</code> (WAN) – Connected to the external network/Internet. (Use DHCP or a static IP from your upstream router. For example, assume it gets an IP <code>192.0.2.100</code> from an upstream NAT for testing Internet access.)</li>
                <li><code>eth1</code> (DMZ) – Static IP <code>10.10.10.1/24</code> (acts as default gateway for the DMZ network).</li>
                <li><code>eth2</code> (LAN) – Static IP <code>192.168.10.1/24</code> (acts as default gateway for the LAN network).</li>
            </ul>
        </li>
        <li><strong>CentOS Web Server (DMZ)</strong> – one interface on DMZ network:
            <ul>
                <li><code>eth0</code> – Static IP <code>10.10.10.10/24</code>, gateway <code>10.10.10.1</code> (Alpine router DMZ IP). DNS can be set to a public DNS (e.g., <code>8.8.8.8</code>) if needed for internet access.</li>
            </ul>
        </li>
        <li><strong>Arch Linux File Server (LAN)</strong> – one interface on LAN network:
            <ul>
                <li><code>eth0</code> – Static IP <code>192.168.10.10/24</code>. For added security, we will not set a default gateway on this server (so it has no direct route to Internet or DMZ via the router). It will still be reachable from LAN, but it won't initiate external connections. (If a gateway is required for updates, you can temporarily add <code>192.168.10.1</code>.)</li>
            </ul>
        </li>
        <li><strong>Ubuntu Desktop Jump Box (LAN)</strong> – one interface on LAN network:
            <ul>
                <li><code>eth0</code> – Static IP <code>192.168.10.50/24</code>, gateway <code>192.168.10.1</code>. DNS can be set to the router or public DNS. This box will be used to reach both the DMZ (e.g. SSH/Web to CentOS) and the LAN (e.g. RDP/SSH to Arch or router).</li>
            </ul>
        </li>
    </ul>
    <p>Make sure each VM is connected to the proper virtual network/switch corresponding to these subnets. (For example, in your hypervisor, Alpine's <code>eth1</code> and CentOS's <code>eth0</code> are connected to a "DMZ" switch, Alpine's <code>eth2</code>, Arch's <code>eth0</code>, and Ubuntu's <code>eth0</code> to a "LAN" switch, etc.)</p>

    <h2>1. Alpine Linux Router Setup (Routing &amp; Firewall)</h2>
    <p>The Alpine Linux router will perform IP forwarding, network address translation (NAT) for internet access, and filtering between LAN and DMZ. We will enable IP forwarding, set up the network interfaces with static IPs, and configure firewall (<code>iptables</code>) rules.</p>

    <h3>1.1 Configure Alpine Network Interfaces</h3>
    <p>Log into the Alpine router VM console. Alpine typically uses the <code>/etc/network/interfaces</code> file with <code>ifupdown</code>. You can use Alpine's setup script or edit the config manually:</p>
    <ul>
        <li>Run the Alpine setup script for networking: <code>setup-interfaces</code> (if available) and assign:
            <ul>
                <li><code>eth0</code> to use DHCP (if your lab provides a WAN via DHCP) or a static external IP.</li>
                <li><code>eth1</code> static IP <code>10.10.10.1/24</code> (no DHCP on DMZ in this guide).</li>
                <li><code>eth2</code> static IP <code>192.168.10.1/24</code>.</li>
                <li>When prompted for default gateway, set it for the WAN (<code>eth0</code>) if needed (e.g., the upstream router IP).</li>
                <li>DNS can be a public server (e.g., <code>8.8.8.8</code>).</li>
            </ul>
        </li>
    </ul>
    <p>Alternatively, manually edit <code>/etc/network/interfaces</code> to include entries for <code>eth1</code> and <code>eth2</code> with the above static IPs, then bring them up with <code>ifup eth1 &amp;&amp; ifup eth2</code>. Verify you can ping CentOS from Alpine (after CentOS is configured) on <code>10.10.10.10</code> and the Ubuntu jump-box on <code>192.168.10.50</code> once everything is up.</p>

    <h3>1.2 Enable IP Forwarding and NAT</h3>
    <p>By default, Alpine (and Linux in general) does not forward IP packets between interfaces until enabled. Do the following on Alpine as root:</p>
    <pre><code class="language-bash"># To see the current settings
sysctl -a | grep ip_forward
# Enable IPv4 forwarding in the kernel (this persists in /etc/sysctl.conf)
echo "net.ipv4.ip_forward=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p  # apply the sysctl settings immediately</code></pre>

    <p>Now install and initialize the <code>iptables</code> service (Alpine is minimal, so it may not be installed by default):</p>
    <pre><code class="language-bash">sudo apk add iptables           # install iptables firewall utilities
sudo rc-update add iptables     # enable iptables service at boot</code></pre>

    <p>Next, add firewall rules for NAT and forwarding. We will set up a basic firewall that implements our policy:</p>
    <ul>
        <li><strong>NAT (Masquerading):</strong> All traffic from LAN or DMZ going out via Alpine's <code>eth0</code> (WAN) will have its source IP masqueraded as Alpine's WAN IP for internet access.</li>
        <li><strong>WAN → DMZ (Port Forwarding):</strong> We will allow outside access to the CentOS web server on HTTP (and HTTPS) by forwarding those ports to the DMZ host.</li>
        <li><strong>LAN ↔ DMZ:</strong> Allow LAN to initiate connections to DMZ, but block DMZ from initiating into LAN. Additionally block the Arch file server specifically from reaching the DMZ (as an extra precaution).</li>
        <li><strong>LAN/DMZ → WAN:</strong> Allow LAN and DMZ to access the Internet (outbound), but unsolicited inbound from WAN is blocked except the forwarded web ports.</li>
        <li><strong>Basic sanity rules:</strong> Allow established/related connections, drop invalid packets, etc.</li>
    </ul>

    <p>We will use <code>iptables</code> commands to implement this. Run the following on Alpine's shell (the <code>eth0</code>, <code>eth1</code>, <code>eth2</code> naming assumes as defined above):</p>
    <pre><code class="language-bash"># Flush any existing rules (optional, to start fresh)
sudo iptables -F
sudo iptables -t nat -F
sudo iptables -t mangle -F
sudo iptables -X

# Default drop on forwarding chain for security
sudo iptables -P FORWARD DROP

# 1) Allow established/related traffic to pass back (for TCP handshakes, etc.)
sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# 2) Block Arch file server from initiating to DMZ (Arch IP = 192.168.10.10)
sudo iptables -A FORWARD -i eth2 -s 192.168.10.10/32 -d 10.10.10.0/24 -j DROP

# 3) Allow LAN to DMZ (other LAN hosts can reach DMZ) and LAN to WAN
sudo iptables -A FORWARD -i eth2 -s 192.168.10.0/24 -o eth1 -d 10.10.10.0/24 -m conntrack --ctstate NEW -j ACCEPT
sudo iptables -A FORWARD -i eth2 -s 192.168.10.0/24 -o eth0 -m conntrack --ctstate NEW -j ACCEPT

# 4) Allow DMZ to WAN (e.g., DMZ server can reach Internet for updates)
sudo iptables -A FORWARD -i eth1 -s 10.10.10.0/24 -o eth0 -m conntrack --ctstate NEW -j ACCEPT

# 5) Block DMZ to LAN (prevent any DMZ host from initiating into LAN)
sudo iptables -A FORWARD -i eth1 -s 10.10.10.0/24 -o eth2 -d 192.168.10.0/24 -j DROP

# 6) Port forward: WAN 80/443 → DMZ web server (10.10.10.10)
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80  -j DNAT --to-destination 10.10.10.10:80  # HTTP
sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 443 -j DNAT --to-destination 10.10.10.10:443 # HTTPS
sudo iptables -A FORWARD -i eth0 -p tcp --dport 80  -d 10.10.10.10 -m conntrack --ctstate NEW -j ACCEPT  # allow forwarded traffic
sudo iptables -A FORWARD -i eth0 -p tcp --dport 443 -d 10.10.10.10 -m conntrack --ctstate NEW -j ACCEPT

# 7) Enable NAT (masquerade) for LAN and DMZ subnets going out via eth0 (WAN)
sudo iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -o eth0 -j MASQUERADE
sudo iptables -t nat -A POSTROUTING -s 10.10.10.0/24   -o eth0 -j MASQUERADE

# (Optional) Allow router itself to be pinged or reached from LAN:
sudo iptables -A INPUT -i eth2 -s 192.168.10.0/24 -m conntrack --ctstate NEW -j ACCEPT
# (Optional) Allow SSH to router from LAN (for management):
sudo iptables -A INPUT -i eth2 -s 192.168.10.0/24 -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
# Drop other inbound traffic to router
sudo iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
sudo iptables -A INPUT -p icmp -j ACCEPT   # allow ping for testing
sudo iptables -A INPUT -p tcp --syn -j DROP</code></pre>

    <p><strong>Explanation of the above rules:</strong> We set the default policy to <code>DROP</code> for forwarding (everything is denied unless whitelisted). We allow established connections to pass (so returning packets in a session are not blocked). We explicitly drop any attempt by the Arch file server (<code>192.168.10.10</code>) to go to the DMZ network. We then allow any new connections from the LAN (<code>192.168.10.0/24</code>) to the DMZ network and to the WAN. We allow the DMZ network to initiate connections out to WAN (internet). We block any new connection from DMZ to LAN. We forward incoming WAN HTTP/HTTPS to the web server in DMZ (<code>10.10.10.10</code>). Finally, we enable NAT masquerading on WAN for both subnets, so that LAN and DMZ hosts can reach the internet with their source IP translated to the router's WAN IP. (The optional <code>INPUT</code> rules allow managing the router from the LAN – adjust as needed.)</p>

    <p>After entering these rules, save them so they persist on reboot:</p>
    <pre><code class="language-bash">sudo /etc/init.d/iptables save    # Save the current iptables rules to /etc/iptables/rules</code></pre>

    <p>Alpine's <code>iptables</code> service (enabled earlier) will load these saved rules on boot. You can verify by listing the rules: <code>sudo iptables -L -v &amp;&amp; sudo iptables -t nat -L -v</code>.</p>

    <h3>Testing the Router &amp; Firewall</h3>
    <p>At this stage, test basic connectivity (after other VMs are configured too):</p>
    <ul>
        <li>From Alpine, try to ping an internet host (e.g., <code>ping -c 4 8.8.8.8</code>) to ensure WAN is working.</li>
        <li>From Ubuntu jump-box (<code>192.168.10.50</code>), ping the CentOS server (<code>10.10.10.10</code>) – this should succeed (LAN to DMZ allowed).</li>
        <li>From CentOS (<code>10.10.10.10</code>), ping the Arch server (<code>192.168.10.10</code>) – this should fail (DMZ to LAN blocked).</li>
        <li>From Arch (<code>192.168.10.10</code>), ping the CentOS server (<code>10.10.10.10</code>) – this should fail (we dropped Arch->DMZ). The Arch server should only communicate with LAN (and it has no gateway set, so it wouldn't know how to reach <code>10.10.10.0/24</code> anyway).</li>
        <li>From Ubuntu, try pinging Arch (<code>192.168.10.10</code>) – should succeed (LAN to LAN).</li>
        <li>If you set up SSH on CentOS, try <code>ssh</code> from Ubuntu to CentOS (should work). Try <code>ssh</code> from CentOS to Ubuntu (should fail, DMZ->LAN).</li>
        <li>Once the web server is up, from Ubuntu you should be able to open a browser to <code>http://10.10.10.10</code> (or to the Alpine's WAN IP <code>http://192.0.2.100</code> if you set port forwarding and have an external test access).</li>
        <li>From outside (simulate by using the host or another external VM), try to access the WAN IP on port 80 – it should be forwarded to the web server's site.</li>
    </ul>
    <p>These tests confirm the firewall segmentation is working as intended.</p>

    <h2>2. CentOS DMZ Web Server Setup (LAMP Stack with Nginx Reverse Proxy)</h2>
    <p>Next, set up the CentOS VM as a web server on the DMZ network. This server will run a classic LAMP stack (Apache, PHP, MariaDB) and we will put Nginx in front of Apache as a reverse proxy. We will also ensure SELinux remains in enforcing mode and configure it to allow our web setup to function (demonstrating SELinux policy enforcement).</p>

    <h3>2.1 CentOS Basic Setup and Package Installation</h3>
    <ul>
        <li><strong>Network Config:</strong> Ensure the CentOS VM's network interface is on the DMZ switch and has the static IP <code>10.10.10.10/24</code>, gateway <code>10.10.10.1</code>. On CentOS, edit <code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> accordingly or use <code>nmtui</code> for convenience. After configuring, test connectivity: you should ping the router (<code>10.10.10.1</code>) and the Ubuntu host (via router) once firewall is open. Also ensure DNS is set (e.g., in <code>/etc/resolv.conf</code>).</li>
        <li><strong>Update System:</strong> It's good practice to update packages first:
            <pre><code class="language-bash">sudo yum update -y    # (Use dnf if CentOS 8+, accordingly)</code></pre>
        </li>
        <li><strong>Install LAMP components:</strong>
            <pre><code class="language-bash">sudo yum install -y httpd php php-mysqlnd mariadb-server</code></pre>
            This installs Apache HTTPd, PHP, and MariaDB (MySQL) server on CentOS. Enable and start these services:
            <pre><code class="language-bash">sudo systemctl enable httpd mariadb
sudo systemctl start httpd mariadb</code></pre>
            Confirm Apache is running (e.g., <code>systemctl status httpd</code>). You can also open a browser on the Ubuntu jump-box to <code>http://10.10.10.10</code> – you should see the Apache default test page.
        </li>
        <li><strong>Secure MariaDB:</strong> (Optional but recommended) run <code>sudo mysql_secure_installation</code> to set a root DB password and remove test DB/users as prompted.</li>
        <li><strong>Test PHP:</strong> Create a test PHP page to ensure PHP is working. For example:
            <pre><code class="language-bash">echo "<?php phpinfo(); ?>" | sudo tee /var/www/html/info.php</code></pre>
            In a browser (from Ubuntu or elsewhere with access), visit <code>http://10.10.10.10/info.php</code>. You should see the PHP info page. Remove it afterwards for security (<code>rm /var/www/html/info.php</code>).
        </li>
    </ul>
    <p>At this point, we have a basic working Apache+PHP (and database ready). Now we'll set up Nginx as a reverse proxy in front of Apache.</p>

    <h3>2.2 Install and Configure Nginx Reverse Proxy</h3>
    <ul>
        <li><strong>Install Nginx:</strong>
            <pre><code class="language-bash">sudo yum install -y nginx
sudo systemctl enable nginx</code></pre>
        </li>
        <li><strong>Configure Nginx:</strong> We want Nginx to listen on port 80 (and 443 for HTTPS if needed) and forward requests to Apache (which we will move to a different port). By default, Apache is listening on 80, which conflicts with Nginx. We have two options:
            <ol>
                <li>Change Apache to listen on another port (e.g., 8080) and have Nginx proxy to <code>localhost:8080</code>.</li>
                <li>Or configure Nginx to listen on port 80 for incoming requests and proxy to Apache's UNIX socket or port 81.</li>
            </ol>
            We'll use option 1 for simplicity.
        </li>
        <li><strong>Reconfigure Apache to port 8080:</strong> Open <code>/etc/httpd/conf/httpd.conf</code> and find the line <code>Listen 80</code>. Change it to <code>Listen 127.0.0.1:8080</code> (we'll bind Apache to localhost on port 8080). Also update any <code>VirtualHost</code> in <code>/etc/httpd/conf.d/</code> to port 8080 if present (e.g., in <code>welcome.conf</code> or others). Then restart Apache:
            <pre><code class="language-bash">sudo systemctl restart httpd</code></pre>
            Verify Apache is now listening on <code>127.0.0.1:8080</code> (use <code>ss -tlnp | grep httpd</code>).
        </li>
        <li><strong>Configure Nginx site:</strong> Create an Nginx config file for the site, e.g., <code>/etc/nginx/conf.d/reverse-proxy.conf</code>:
            <pre><code class="language-nginx">server {
    listen       80;
    server_name  _;  # catch all

    access_log  /var/log/nginx/access.log  main;
    error_log   /var/log/nginx/error.log warn;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}</code></pre>
            This configuration tells Nginx to listen on port 80 and forward all requests to the Apache backend on <code>localhost:8080</code>. It also passes along the original host and IP info to Apache via headers.
        </li>
        <li><strong>Start Nginx:</strong>
            <pre><code class="language-bash">sudo systemctl start nginx</code></pre>
            Now Nginx should be listening on <code>10.10.10.10:80</code>. If you visit the web server from the jump-box browser, you should still see the Apache test page, but it's now coming through Nginx. Nginx is effectively acting as a reverse proxy in front of Apache.
        </li>
    </ul>

    <h3>2.3 SELinux Configuration for Reverse Proxy</h3>
    <p>CentOS comes with SELinux enabled (enforcing) by default, which is a good thing for security. We keep SELinux in enforcing to demonstrate policy enforcement, but we need to adjust it to allow our custom configuration (Nginx->Apache proxy).</p>

    <p>By default, SELinux HTTP policy expects web servers to run on standard ports (80, 443). We changed Apache to listen on 8080, and we have Nginx (running as an HTTP daemon) trying to connect to <code>localhost:8080</code>. Out-of-the-box, SELinux will prevent Nginx from connecting to Apache on port 8080 because that's considered an unallowed network connection. (SELinux confines the Nginx process in the <code>httpd_t</code> domain which by default cannot initiate outbound connections to arbitrary ports.) If we check <code>/var/log/audit/audit.log</code> after trying to load the site, we would likely see a denied message.</p>

    <p>To fix this, we have a couple of options:</p>
    <ol>
        <li>Allow the web daemon to make network connections in general.</li>
        <li>Or specifically label port 8080 as an HTTP port.</li>
    </ol>

    <p>The simpler approach for a workshop is to enable the SELinux boolean that permits HTTP network connections. There is a boolean <code>httpd_can_network_connect</code> which, when ON, allows processes in the <code>httpd_t</code> domain (like Apache or Nginx) to initiate network connections. There's also a more specific <code>httpd_can_network_relay</code> for reverse proxy usage, but enabling the general network connect will cover it.</p>

    <p>Run the following on CentOS to update SELinux policy on the fly:</p>
    <pre><code class="language-bash">sudo setsebool -P httpd_can_network_connect on</code></pre>

    <p>This sets the boolean persistently (<code>-P</code>). Now Nginx is allowed to connect to Apache's 8080 port, and SELinux will no longer block it. (Alternatively, we could have added port 8080 to the <code>http_port_t</code> context via <code>semanage port -a -t http_port_t -p tcp 8080</code>, which is another valid solution. But using the boolean is quick for our case.)</p>

    <div class="alert alert-info">
        <strong>Note:</strong> We did not disable SELinux at any point – we adjusted it. This demonstrates how SELinux provides a secure default (it "prevents NGINX from accessing port 8888 or any other non-standard port" in a reverse proxy scenario) and how we can selectively enable needed access. You can check SELinux status with <code>sestatus</code> (it should show "Current mode: enforcing"). The site should now work via Nginx with SELinux enforcing. If you had an SELinux denial before, you can verify it's gone by retrying access and checking <code>audit.log</code> again.
    </div>

    <h3>2.4 Deploy a Sample PHP Website</h3>
    <p>For demonstration, let's set up a simple PHP page served through Apache (and thus via Nginx). Create <code>/var/www/html/index.php</code> with a basic script. For example:</p>
    <pre><code class="language-php">&lt;?php
  echo "&lt;h1&gt;Welcome to the DMZ Web Server&lt;/h1&gt;";
  echo "&lt;p&gt;This is served by Apache PHP backend through Nginx reverse proxy.&lt;/p&gt;";
?&gt;</code></pre>

    <p>Ensure ownership is <code>apache:apache</code> (or appropriate) for the file. Navigate to <code>http://10.10.10.10/</code> from the Ubuntu jump-box browser – you should see the welcome message. This confirms PHP is working behind the proxy. (Nginx is just passing the request to Apache, which executes PHP and returns the output.)</p>

    <h3>2.5 Firewalld (if applicable)</h3>
    <p>If CentOS has <code>firewalld</code> enabled by default, you might need to adjust it to allow HTTP/HTTPS. Since our Alpine router already controls external access, you could even disable <code>firewalld</code> on CentOS or open the ports on the CentOS VM for LAN access. For simplicity, you can run: <code>sudo systemctl disable --now firewalld</code> on the CentOS VM (the Alpine firewall is primary here).</p>

    <p>The CentOS web server in the DMZ is now fully set up with LAMP, behind Nginx, and SELinux is actively protecting it (try switching SELinux to permissive mode with <code>setenforce 0</code> and see that nothing is being blocked, then back to 1 – we prefer to keep it enforcing).</p>

    <h2>3. Arch Linux LAN File Server Setup (FTP and Samba)</h2>
    <p>Now we configure the Arch Linux VM as an internal file server, providing FTP and SMB file sharing services. This server is on the LAN and should only be accessible from the LAN. We will set up <code>vsftpd</code> and <code>Samba</code>, and also show how to restrict these services to the LAN network.</p>

    <h3>3.1 Arch Linux Basic Config</h3>
    <p>Ensure the Arch VM is connected to the LAN and has IP <code>192.168.10.10/24</code> (with no gateway set, as discussed). Update the system (<code>sudo pacman -Syu</code>) if needed.</p>

    <h3>3.2 Install and Configure FTP (vsftpd)</h3>
    <ul>
        <li><strong>Install vsftpd:</strong>
            <pre><code class="language-bash">sudo pacman -S vsftpd</code></pre>
        </li>
        <li><strong>Enable and start the service:</strong>
            <pre><code class="language-bash">sudo systemctl enable vsftpd
sudo systemctl start vsftpd</code></pre>
        </li>
        <li><strong>Configure vsftpd:</strong> Open <code>/etc/vsftpd.conf</code> in an editor. We will set it up to allow local user logins and optionally anonymous read (depending on needs). Key settings to configure:
            <ul>
                <li><code>local_enable=YES</code> – allows local Unix users to login via FTP.</li>
                <li><code>write_enable=YES</code> – allows mutation (uploads, deletions) – without this, all FTP sessions are read-only.</li>
                <li><code>chroot_local_user=YES</code> – jail local users in their home directory after login (for security).</li>
                <li>(Optional) If you want an anonymous read-only share, set <code>anonymous_enable=YES</code> and specify <code>anon_root=/srv/ftp</code> with proper perms; for this workshop, we'll focus on authenticated access.</li>
                <li>You may also limit the <code>listen_address</code> to the LAN IP if needed, but since the server only has a LAN IP and the router blocks outside access, it's fine.</li>
            </ul>
            After editing, save the file and restart vsftpd (<code>sudo systemctl restart vsftpd</code>).
        </li>
        <li><strong>Create an FTP user:</strong> We need a user account for FTP login (<code>vsftpd</code> will use system accounts). You can use an existing user or create a dedicated one. For example:
            <pre><code class="language-bash">sudo useradd -m ftpuser -s /bin/nologin   # create a user with no shell (FTP only)
sudo passwd ftpuser                      # set a password for FTP login</code></pre>
            This user's home directory (e.g., <code>/home/ftpuser</code>) will be the FTP root (with chroot enabled, they won't escape above it).
        </li>
        <li><strong>Test FTP from jump-box:</strong> From the Ubuntu desktop, you can test FTP:
            <ul>
                <li>On Linux, run: <code>ftp 192.168.10.10</code> and login with <code>ftpuser</code> and the password. Try uploading a file (<code>put</code>) or downloading (<code>get</code>) to ensure it works.</li>
                <li>Alternatively, use a GUI FTP client on Ubuntu or command-line <code>curl -u ftpuser ftp://192.168.10.10/</code>.</li>
            </ul>
        </li>
    </ul>
    <p>By enabling <code>local_enable=YES</code> and <code>write_enable=YES</code>, we allowed authenticated users to upload files. The <code>chroot_local_user=YES</code> setting locks the user into their home directory upon login (preventing navigating to other system directories), which is a good security practice for an FTP server.</p>

    <h3>3.3 Install and Configure Samba (SMB file sharing)</h3>
    <ul>
        <li><strong>Install Samba:</strong>
            <pre><code class="language-bash">sudo pacman -S samba</code></pre>
        </li>
        <li><strong>Samba Configuration File:</strong> Copy the default example as a starting point:
            <pre><code class="language-bash">sudo cp /etc/samba/smb.conf.default /etc/samba/smb.conf</code></pre>
            Now edit <code>/etc/samba/smb.conf</code>. Under the <code>[global]</code> section, set the <code>workgroup</code> if needed (default <code>WORKGROUP</code> is usually fine, which matches Windows default). You can also set <code>interfaces = 192.168.10.10/24</code> and <code>bind interfaces only = yes</code> to make Samba listen only on the LAN interface (added security to ensure it's not listening on any unintended interface).
        </li>
        <li><strong>Define a share:</strong> For example, add at the bottom of the file:
            <pre><code class="language-ini">[fileshare]
comment = Shared Files
path = /srv/samba/share
browseable = yes
read only = no
valid users = smbuser</code></pre>
            This defines a share named "fileshare" located at <code>/srv/samba/share</code>. It's browseable and writeable, but only accessible by the user "smbuser".
        </li>
        <li><strong>Create the shared directory and user:</strong>
            <pre><code class="language-bash">sudo mkdir -p /srv/samba/share
sudo chown nobody:nobody /srv/samba/share   # or choose a group, depending on use</code></pre>
            For a simple setup, we'll use a single Samba user. Create a system user (if not already existing) and set a Samba password for them:
            <pre><code class="language-bash">sudo useradd -M smbuser -s /sbin/nologin    # create a no-login user (no home needed, using share dir)
sudo smbpasswd -a smbuser                   # set a Samba password for smbuser
sudo smbpasswd -e smbuser                   # enable the user (if not auto-enabled)</code></pre>
            Ensure the user has permission on the share path if using <code>valid users</code>. In our case, we set <code>nobody:nobody</code> on the share and didn't add <code>smbuser</code> to it – for simplicity, instead assign ownership:
            <pre><code class="language-bash">sudo chown smbuser /srv/samba/share</code></pre>
            Or adjust the <code>valid users</code> to a group that <code>smbuser</code> is part of. The goal is <code>smbuser</code> can read/write in that directory.
        </li>
        <li><strong>Start Samba services:</strong> Enable and start the SMB (and NMB) daemons:
            <pre><code class="language-bash">sudo systemctl enable smb nmb
sudo systemctl start smb nmb</code></pre>
            Samba should now be running and serving the defined share. You can verify the config syntax with <code>testparm</code> (Samba's tool to check <code>smb.conf</code>).
        </li>
        <li><strong>Test SMB access:</strong> From the Ubuntu jump-box, install the Samba client tools:
            <pre><code class="language-bash">sudo apt-get install -y smbclient
smbclient -L 192.168.10.10 -U smbuser</code></pre>
            Enter the password when prompted. You should see the "fileshare" listed in the output. Then try to connect:
            <pre><code class="language-bash">smbclient //192.168.10.10/fileshare -U smbuser</code></pre>
            Once in the SMB shell, use commands like <code>dir</code> to list files, and <code>put</code> to upload, <code>get</code> to download files, etc., to ensure it works. You can also mount the share on Ubuntu via GUI (Files app -> "Connect to Server" with <code>smb://192.168.10.10/fileshare</code>).
        </li>
    </ul>
    <p>The Samba share we created requires authentication (username/password) and is only accessible to our <code>smbuser</code> account. This demonstrates a private file share. If you wanted a public share (no auth), you could set <code>guest ok = yes</code> and use the <code>nobody</code> account, but that's optional.</p>

    <div class="alert alert-warning">
        <strong>Security Note:</strong> Since this server is only in LAN, we rely on the Alpine router to block any outside or DMZ access to these services. We also configured the services to only listen or be available on the LAN interface. For additional security, you could configure firewall on Arch (with <code>iptables</code> or <code>ufw</code>) to only allow LAN source addresses, but in our scenario it's not necessary. The router's firewall already ensures, for instance, that the DMZ cannot reach the Samba or FTP ports in LAN. (Remember, we blocked DMZ->LAN entirely, and also Arch has no route to DMZ.)
    </div>

    <h2>4. Ubuntu Desktop Jump-Box Setup (Access &amp; Testing)</h2>
    <p>The Ubuntu Desktop doesn't require complex setup – it's primarily a client and admin workstation in the LAN. Ensure it has network configured (<code>192.168.10.50/24</code>, gateway <code>192.168.10.1</code>, and Internet access through the router). You might want to install some client tools:</p>
    <ul>
        <li><strong>For SSH:</strong> <code>sudo apt-get install -y openssh-client</code> (SSH client should be installed by default; if you want to SSH into the Ubuntu box from elsewhere, install <code>openssh-server</code> and open port if needed).</li>
        <li><strong>Browser:</strong> Firefox/Chrome should be installed for web testing.</li>
        <li><strong>For RDP/VNC:</strong> (if you plan to remote into it, set up as needed, but not required here).</li>
        <li><strong>For FTP/SMB:</strong> We already installed <code>smbclient</code>. You can also install an FTP client or just use the command line tools as we did.</li>
    </ul>

    <p>Use the Ubuntu box to test connectivity and access to all services in the network:</p>
    <ul>
        <li><strong>Web Server (CentOS):</strong> Open a browser to <code>http://10.10.10.10</code> – you should see the demo PHP page through Nginx/Apache. Try both the DMZ IP and (if you configured port forwarding) the Alpine's WAN IP. The site should load in both cases (the latter proving the port forwarding from WAN works).</li>
        <li><strong>SSH to CentOS:</strong> If you set up SSH on CentOS (enable with <code>sudo systemctl start sshd</code>), test <code>ssh 10.10.10.10</code> – it should connect (LAN to DMZ allowed).</li>
        <li><strong>FTP Server (Arch):</strong> Connect as <code>ftpuser</code> using an FTP client or <code>ftp 192.168.10.10</code> – should login and list directories. (DMZ cannot do this, only LAN.)</li>
        <li><strong>SMB Server (Arch):</strong> Access the Samba share. On Ubuntu, you can do in file manager <code>smb://192.168.10.10/fileshare</code>, or use <code>smbclient</code> as shown. You should be prompted for credentials and then see the shared folder. Try creating a file.</li>
        <li><strong>Internet:</strong> From Ubuntu, verify you can reach the Internet via Alpine (e.g., browse to a website, or <code>ping 8.8.8.8</code>). The Alpine should NAT your traffic out. Also test that the CentOS DMZ server can ping out to say <code>ping -c4 8.8.8.8</code> (should work, since we allowed DMZ->WAN).</li>
    </ul>

    <p>Everything should now be functioning with correct access controls:</p>
    <ul>
        <li>External users (simulated by any host on the WAN side) can only reach the web server (and only on the allowed ports).</li>
        <li>The DMZ web server cannot initiate connections into the LAN (it's blocked by Alpine).</li>
        <li>The internal jump-box (and any LAN host) can reach the DMZ services (for maintenance or usage).</li>
        <li>The internal file server is invisible to the DMZ and outside; it only serves the LAN. We even prevented it from talking to the DMZ from its side.</li>
        <li>SELinux is enforcing on CentOS, so if someone tried to, say, put web content in a weird location or Nginx tried to do something unusual, SELinux would intervene. We only enabled a specific policy boolean to allow the proxy connection, rather than turning SELinux off. This highlights how SELinux policies add a layer of protection – e.g., by default NGINX could not access Apache's port until we explicitly allowed it, which is a deliberate security policy.</li>
    </ul>

    <h2>5. Summary and Next Steps</h2>
    <p>In this workshop, we set up a realistic multi-tier network environment:</p>
    <ul>
        <li>A lightweight Alpine Linux router with <code>iptables</code> providing segmentation between a LAN and DMZ, implementing a "demilitarized zone" network design. Our firewall rules ensure that outside traffic can reach the DMZ server but not the internal LAN, and internal hosts can reach the DMZ as needed. We used NAT for internet access and showed port-forwarding for public services.</li>
        <li>A CentOS web server in the DMZ running a LAMP stack with an Nginx reverse proxy. We deployed a sample PHP site and configured SELinux properly rather than disabling it – demonstrating how to adjust SELinux booleans (like <code>httpd_can_network_connect</code>) to allow necessary access while keeping the system secure.</li>
        <li>An Arch Linux file server in the LAN providing internal FTP and SMB services. We configured <code>vsftpd</code> and <code>Samba</code> with appropriate settings (enabling local logins, restricting write access, etc.). The file server is only accessible from the LAN – the router's firewall and the network design protect it from the DMZ or outside.</li>
        <li>An Ubuntu Desktop jump-box used for testing and administration, simulating an admin's workstation that can reach into the DMZ for management and use internal services.</li>
    </ul>

    <p>You can extend this setup by adding more rules (for example, logging dropped packets, or further restricting which LAN hosts can access the DMZ), setting up HTTPS with certificates on Nginx, adding intrusion detection, etc. For instance, you might only allow the Jump-box's IP to access the DMZ SSH port, while blocking other LAN IPs – this would tighten security if needed. SELinux on CentOS can be further explored (check audit logs if you, say, try to serve content from a non-standard directory and see how to label files correctly).</p>

    <p>This step-by-step guide can be used as a workshop to practice networking and security on a virtual lab. It demonstrates fundamental concepts of network segmentation (LAN vs DMZ), firewall configuration with <code>iptables</code>, service configuration on various Linux distros, and security best practices like least privilege (SELinux, chroot, account restrictions). By following these steps, you've built a mini network that models what is used in real-world scenarios for isolating internal resources from public-facing ones, all within a virtualized environment for learning.</p>
</body>
</html>
